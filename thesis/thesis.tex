\documentclass[supercite]{HustGraduPaper}

\title{高性能异步编程框架的设计与实现}
\author{车春池}
\school{计算机科学与技术}
\classnum{校际交流1801}
\stunum{U201816030}
\instructor{邵志远}
\date{2022年0月0日}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{xltxtra}
\usepackage{bm}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}

\pgfplotsset{compat=1.16}

\newcommand{\cfig}[3]{
  \begin{figure}[htb]
    \centering
    \includegraphics[width=#2\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{figure}
}
\newcommand{\sfig}[3]{
  \begin{subfigure}[b]{#2\textwidth}
    \includegraphics[width=\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{subfigure}
}
\newcommand{\xfig}[3]{
  \begin{figure}[htb]
    \centering
    #3
    \caption{#2}
    \label{fig:#1}
  \end{figure}
}

\newcommand{\rfig}[1]{\autoref{fig:#1}}
\newcommand{\ralg}[1]{\autoref{alg:#1}}
\newcommand{\rthm}[1]{\autoref{thm:#1}}
\newcommand{\rlem}[1]{\autoref{lem:#1}}
\newcommand{\reqn}[1]{\autoref{eqn:#1}}
\newcommand{\rtbl}[1]{\autoref{tbl:#1}}

\algnewcommand\Null{\textsc{null }}
\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\Input{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Output{\item[\algorithmicoutput]}
\algnewcommand\algorithmicbreak{\textbf{break}}
\algnewcommand\Break{\algorithmicbreak}
\algnewcommand\algorithmiccontinue{\textbf{continue}}
\algnewcommand\Continue{\algorithmiccontinue}
\algnewcommand{\LeftCom}[1]{\State $\triangleright$ #1}

\newtheorem{thm}{定理}[section]
\newtheorem{lem}{引理}[section]

\colorlet{shadecolor}{black!15}

\theoremstyle{definition}
\newtheorem{alg}{算法}[section]

\def\thmautorefname~#1\null{定理~#1~\null}
\def\lemautorefname~#1\null{引理~#1~\null}
\def\algautorefname~#1\null{算法~#1~\null}

\begin{document}

\maketitle

\statement

\clearpage

\pagenumbering{Roman}

\begin{cnabstract}{异步I/O；协程；异步编程框架}

在大数据时代，随着互联网用户体量的高速增长，数据中心面对数量越来越庞大，频度越来越高
的数据访问，对更为高效的数据输入输出（下文简称I/O）技术方案的需求也日益增长。
在此背景下，传统服务端开发中使用的同步数据I/O模式由于线程阻塞问题逐渐在性能考验上力不从心，
因此工业界和学术界正在探索和研究更为高效的异步I/O方案，希望以此来提高系统的整体性能。\par

同时，在系统并发编程领域，传统的多线程编程模式也慢慢展现出了它的弊端。近年来存储设备的性能
不断提高，现今某些高速存储设备进行一次I/O操作的开销已经能和一次线程切换的开销不分伯仲，
这意味着每进行一次线程切换系统就浪费一次I/O的时间。
面对线程切换开销重的现状，现代许多编程语言均提出了协程的概念，旨在提供一个更轻量，高效的并发编程模式。\par

本毕业设计以异步I/O和协程为基点，设计和实现一款高性能的异步编程框架。
基于Linux io\underline{~}uring为底层异步I/O接口和使用无栈协程作为并发编程模式，
该框架具备高性能，低资源占用和易于编程的特点。
同时，对此框架进行性能测试，实验结果验证了异步I/O模式和协程能实实在在地对系统性能产生积极的影响。

\end{cnabstract}

\begin{enabstract}{Asynchronous I/O, Coroutine, Programming framework}

In the era of big data, with the rapid growth of the number of Internet users, data centers
are faced with increasingly large and frequent data access, and the demand for more efficient
data input and output technical solutions is also increasing. In this context, the synchronous
data I/O mode used in traditional server development is gradually unable to perform performance
tests due to thread blocking problems.Therefore, the industry and academia are exploring and
researching more efficient asynchronous I/O solutions, hoping to improve the overall performance
of the system.\par

At the same time, in the field of system concurrent programming, the traditional multi-threaded
programming mode has gradually shown its drawbacks.In recent years, the performance of storage
devices has been continuously improved. Today, the overhead of one I/O operaion on some high-speed
storage devices is comparable to the overhead of on thread switching. This means that every time
the system is switched between threads, an I/O time is wasted. Faced with the current situation
of heavy thread switching overhead, many modern programming languages have proposed the concept
of coroutines, aiming to provide a lighter and more efficient concurrent programming model.\par

Based on asynchronous I/O and coroutines, this graduation project designs and implements a
high-performance asynchronous programming framwork. Based on Linux io\underline{~}uring as
the underlying asynchronous I/O interface and the use of stackless coroutines as a concurrent
programming mode, the framework has the characteristics of high performance, low resource consumption
and easy programming. At the same time, the performance of this framework is tested, and the
result of the experiment verify that asynchronous I/O modes and coroutines can actually have a
positive impact on system performance.\par

\end{enabstract}

\tableofcontents[level=2]
\clearpage

\pagenumbering{arabic}

\section{绪论}

本章我们首先介绍了当前并发系统编程领域面临的挑战和技术发展趋势，然后分析了异步I/O和协程
的产生及发展现状，接着介绍了国内外针对异步编程框架的相关研究工作，最后对本文的主要研究内容
及工作意义作了具体说明。

\subsection{课题背景}

\subsubsection{研究背景和趋势}
Linux 平台上的I/O模型经历了几个发展阶段：阻塞，非阻塞，多路复用，信号驱动，异步。其中前四种均属于
同步I/O模式。同步I/O的共性是对于调用过程的双方：用户程序和硬件设备，它们之间流动的数据需要经过
操作系统内核进行同步，完全准备好后，才能复制到用户空间，用户程序才能继续往下执行。而数据等待的过程
会阻塞用户线程，直到整个I/O调用链路完成。线程阻塞问题导致了同步I/O的低效，因此异步I/O作为一个高性能
解决方案被提出，它的特点是用户程序发起I/O请求后，不需要进行任何的等待，可以从容地转向处理其他任务，
然后在合适的时机检查数据传输是否完成，再对该数据进行相应处理。异步I/O模式解决了线程阻塞的问题，
提高了资源利用率。\par

异步I/O通常需要操作系统内核提供支持。Linux 平台存在原生的异步I/O接口：libaio，但其存在复杂难用，性能低
等问题，因此Linux在很长一段时间内处于缺少异步I/O接口的状况。这导致系统存储领域在很多时候会采用
绕过内核(kernel bypass)作为高性能解决方案。终于，在5.1版本，Linux新增了io\underline{~}uring特性，
提供了一个简单易用，高性能的异步I/O接口。并且在随之而来的性能评估结果中，io\underline{~}uring 展现出
了足够强大的性能潜力。因此，基于io\underline{~}uring的学术研究和工程变革势在必行。\par

\subsubsection{异步I/O和协程的结合}
尽管异步I/O在理论上拥有比传统同步I/O更好的性能优势，但同时其带来的编程上的复杂性也是不容忽视的一部分。
如何降低异步I/O带来的编程复杂度，是软件开发者必需考虑的问题之一。针对这个问题，工业界提出了一个
解决方案：通过\textbf{协程}与异步I/O结合进而降低编程难度。\par

协程（英文 coroutine）一词最早出自于上个世纪的程序员马尔文·康威，关于协程的论文\cite{paper1}最早在
1963年发表。协程可以被理解为是一个可以随时挂起和恢复运行的函数。它可以通过\textbf{yield}
来让出当前CPU，然后运行其他协程；它也可以通过\textbf{resume}来恢复执行。当一个协程被恢复的时候，
它会从上次yield调用的位置继续执行。协程和线程类似，属于一种并发编程模式。\par

当协程和异步I/O结合后，可以让协程A在发起I/O请求后挂起，然后调度运行其他协程。等待I/O操作完成后，
再恢复运行协程A，这样就可以充分利用CPU资源。协程的运作模式和异步I/O浑然天成。\par

\subsubsection{面临的问题和挑战}
\textbf{高性能高可用的异步编程框架}。前两小节介绍的io\underline{~}uring和协程均为较原始，较底层的概念，
两者对于不熟悉操作系统和编程语言底层的一般应用软件开发者而言，无论是在理解原理上还是在工程实践上
都存在较高难度。在现代的软件开发领域，分层设计已成共识，因此上层应用开发者需要一个易用的
\textbf{异步编程框架}。通过该框架，他们可以在不了解io\underline{~}uring和协程底层原理的情况下
充分利用到两者的高性能特点，从中收益。\par

这种异步编程框架，在不同的编程语言里面存在不同称呼，比如在C++语言里面它被称为\textbf{协程库}，
在Rust语言里面被称为\textbf{异步运行时}。但是不管在哪种编程语言里面，它的存在意义是一致的：
对底层操作系统的异步I/O接口和编程语言层面的协程进行统一封装，向上层应用程序的构建提供简单易用的
异步编程接口。\par

遗憾的是，目前的系统编程领域的软件生态对于上述的异步编程框架暂时留有较大一片空白。尽管存在一些相关
的开源项目，但各自在实际应用中都暴露了或多或少的不足。因此我们分别基于Rust语言和C++语言设计并实现了
一个异步编程框架，对底层io\underline{~}uring和协程进行了封装，向上层应用开发提供了简单易用的编程接口，
希望可以借此解决传统并发编程和系统编程中的一些痛点。\par

\subsection{国内外研究现状}

\subsubsection{Tokio：Rust异步运行时}
在Rust语言开发领域内，上述的异步编程框架在这里被称为\textbf{异步运行时}（Async Runtime）。
Tokio\cite{repo1}是目前Rust社区里最成熟，也是为数不多广泛应用于工业界研发的Rust异步运行时。
Tokio 现已推出1.0版本，它提供了基于多线程池的协程调度器和基于epoll的异步网络编程接口。
同时，Tokio具有轻量，安全可靠的特点，它可以减少应用程序的崩溃和增加线上系统的稳定性。
但是，相比与在网络编程方面的优越性，Tokio在存储领域的表现则相形见绌，因为它在文件I/O上
使用的是同步I/O模式，而在上文已经提到过同步I/O的低效。\par

\subsubsection{Libco：C++协程库}
在C++语言开发领域内，上述的异步编程框架在这里被称为\textbf{协程库}。
在C++20之前，C++语言本身不支持协程，开发者们通常通过第三方协程库来获得协程的底层支持。
其中，微信团队开源的\textbf{libco}项目就是知名度较高的一个。libco是微信后台大规模使用的
C/C++协程库，自从2013年开始到如今仍稳定运行在微信后台的大规模服务器集群上。
微信作为支撑上亿用户的国民级软件，它所使用的协程库libco无疑在性能，稳定性上拥有非常优秀
的表现，但它仍然存在一定的缺点。一是libco对使用者的要求较高，一般开发者无法很好地驾驭；
二是C++20后在编程语言层面提供了协程支持，而C++20官方的协程标准和libco不兼容，
因此libco的使用价值会逐渐变小。\par

\subsubsection{Goroutine: Go语言原生协程}
说到协程，就不得不提一下Go语言从诞生之际就根植于其基因之中的\textbf{Goroutine}：Go语言原生协程。
Goroutine是Go语言中最为基本的执行单元，它本质上是Go语言原生的一种协程实现。
Go语言中的协程，也就是Goroutine，具有着易于编程的特点，只需要一行代码则可以生成一个协程，
并且开发者不需要关心其中的底层细节。可以说Go语言逐渐成为国内大厂后端开发的首选语言，
Goroutine功不可没。然而，Goroutine由于语言本身的垃圾回收机制，在性能上相比Rust/C++等
零成本开销语言稍逊一筹。同时，Go语言向开发者隐藏了底层协程调度等细节，也就意味着它剥夺了开发者
根据业务场景进行针对性优化的能力，而Rust/C++则能做到这一点。\par

\subsection{课题研究的意义，内容和目标}

\subsubsection{课题研究的意义}
本课题将围绕异步I/O和协程进行，目标是基于身为异步I/O接口之一的io\underline{~}uring和协程
设计并实现一款高性能的异步编程框架，
有助于解决传统并发编程中同步I/O阻塞线程和线程切换开销大的问题，存在能验证异步I/O和协程可以带来
性能提升的理论意义和向应用软件开发者提供简单易用，高性能的异步编程接口的实用意义。\par

\subsubsection{课题研究的内容}
\begin{enumerate}
  \item Linux io\underline{~}uring的底层原理和调用规范；
  \item Rust/C++协程的底层原理和编程范式；
  \item 构思设计如何结合io\underline{~}uring和协程实现异步编程框架；
  \item 将(3)中的设计落实到工程实践上，完成代码实现；
  \item 基于(4)中实现的异步编程框架进行性能测试，验证异步I/O和协程带来的性能优势。
\end{enumerate}

\subsubsection{课题研究的目标}
探索一种结合io\underline{~}uring和协程的编程模式，在将其代码实现为异步编程框架的同时，验证两者在
系统编程领域能否带来，能带来多少性能提升。\par

\subsection{论文结构}
TODO

\section{背景技术概述}
\subsection{同步I/O与异步I/O}
Linux平台上的I/O操作从场景视角看大致可以分为两种：网络I/O和文件I/O，下文的讨论对其不予区分。\par

一个I/O操作可以从发起者和处理者角度分成两个过程:
\begin{enumerate}
    \item 发起者发起I/O请求；
    \item 处理者处理I/O请求。
\end{enumerate}\par
而同步I/O和异步I/O的区分标准是：在整个I/O操作过程中，是否存在发起者和处理者中某一方或双方
因需要同步步调而导致的阻塞现象。如果存在，则为同步I/O，反之为异步I/O。
在Linux的语境下，发起者通常指用户线程，处理者通常指操作系统内核。\par

Linux上存在五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用，信号驱动I/O，异步I/O。
其中前四种属于同步I/O模型，第五种属于异步I/O模型。下面将会对这五种I/O模型进行详细分析。\par

\subsubsection{阻塞I/O模型}
用户线程发起I/O请求后，进入内核态，内核线程请求硬件设备，等待数据准备好后，内核线程将数据拷贝到用户态空间，
然后返回到用户态，用户线程得以继续执行。在此场景用户线程在执行流进入内核态到返回到用户态之间的这段时间内，
一直处于阻塞状态，因此阻塞I/O属于同步I/O模型。\par

典型例子：Linux上的read(2)，write(2)系统调用和配置为阻塞的套接字。\par

\cfig{block-io}{0.5}{阻塞I/O模型}

\subsubsection{非阻塞I/O模型}
用户线程发起I/O请求后，进入内核态，内核线程检查数据准备状态，这时候会有两种情况：
\begin{enumerate}
  \item 数据未就绪，这时候内核会返回一个错误信号给用户线程，用户线程收到错误信号，需要再次发起系统调用进入内核；
  \item 数据已就绪，内核将缓冲区数据拷贝到用户态空间，返回到用户态。
\end{enumerate}

在此场景，用户线程需要不断轮询内核，直到内核执行上面第二种操作，本质上用户线程在轮询的过程中也是处于
阻塞状态，因此非阻塞I/O也属于同步I/O模型。\par

典型例子：Linux上配置为NONBLOCK的套接字。\par

\cfig{nonblock-io}{0.5}{非阻塞I/O模型}

\subsubsection{I/O复用模型}
多个用户线程注册I/O请求到一个复用器上，然后使用一个用户线程监听该复用器。用户线程提交监听请求后，
进入内核态，内核遍历复用器上的I/O请求并请求硬件设备。当多个I/O请求中某个请求的数据就绪后，
内核将其拷贝到用户态空间，然后返回到用户态，用户线程继续执行。在此场景，用户线程在发起系统调用进入内核后
到返回到用户态之间的这段时间内，一直处于阻塞状态，因此I/O复用依然属于同步I/O模型。\par

I/O复用的好处在于可以通过一个用户线程的阻塞换取多个用户线程的非阻塞，获得整体上的性能提升。Linux 上的
select, poll, epoll等机制就是典型的I/O复用模型\par

典型例子：Linux上的select，poll，epoll机制。\par

\cfig{io-multiplex}{0.7}{I/O复用模型}

\subsubsection{信号驱动I/O模型}
信号驱动I/O模型通常用于Linux上的网络编程。用户线程通过sigaction系统调用在某个套接字（socket）上
注册信号处理函数，注册完成后返回用户态，此时用户线程不阻塞。与此同时，内核线程请求硬件设备，
当套接字上有数据报准备好时，向用户线程递交一个SIGIO信号。用户线程收到信号后，调用信号处理函数进行真正
的I/O请求（例如recvfrom(2)），此时会重新进入内核态，内核线程拷贝数据到用户态空间后，再回到用户态，
用户线程继续执行。用户线程在第二次进入内核态到再次回到用户态之间的这段时间内，一直处于阻塞状态，
因此信号驱动I/O还是属于同步I/O模型。\par

信号驱动I/O的好处在于用户线程第二次进入内核态时，套接字上已经有数据报到达了，内核线程这时候只需要做
数据拷贝动作而不需要等待，节省了等待数据的时间。\par

典型例子：Linux上的sigaction系统调用。\par

\cfig{signal-driven}{0.7}{信号驱动I/O模型}

\subsubsection{异步I/O模型}
以上四种I/O模型都属于同步I/O，共同特点是它们都存在某个时间段内的阻塞现象。\par

异步I/O在整个I/O操作过程中不存在阻塞现象。用户线程通过系统调用发起I/O请求后，首次进入内核态，
内核线程收到请求后进行处理，然后不做任何等待直接返回到用户态，用户线程继续执行。
当内核等待数据就绪并完成数据拷贝后，会通过某种方式通知用户。用户线程收到通知后，便可从容地处理数据。\par

异步I/O的好处是对于用户线程来说，整个I/O操作过程不存在任何阻塞现象，CPU资源得到充分的利用。\par

典型例子：Linux上的io\underline{~}uring特性。\par

\cfig{async-io}{0.7}{异步I/O模型}

\subsection{Linux io\underline{~}uring}

\subsubsection{旧时代的异步I/O接口：AIO}
在io\underline{~}uring之前，Linux平台存在原生的异步I/O接口：AIO，但AIO的使用存在诸多限制：

\begin{enumerate}
  \item 最大的限制在于AIO仅支持无缓冲的I/O访问，而无缓冲的限制导致AIO接口在大部分场景下都不可用。
    对于正常的带有缓冲的I/O访问来说，AIO接口的底层运作方式依然是同步的。
  \item 尽管AIO接口的使用者满足了所有使得I/O操作异步的条件，有时候它依然不以异步的方式进行运作。
    比如如果需要元数据来执行I/O操作，那么该I/O请求会被阻塞。
  \item API设计不当，AIO接口的实现中存在较多对用户程序来说不需要的内存拷贝，这导致性能受到影响。
\end{enumerate}

在很长一段时间内，Linux内核开发者们为了解决上述的第一个限制煞费苦心，但依然没有得到令人满意的结果。
与此同时，伴随着延迟达到10毫秒以下的高IOPS硬件设备的出现，AIO接口开始显得力不从心了。对于这些高速设备来说，
Linux内核接口的低效反而成为了它们发挥极致性能的拖油瓶。\par

最重要的是上述限制导致AIO接口在很多场景下都不可用，因此在很长一段时间内Linux平台都处于缺少异步I/O接口
的状况，这给应用开发者带来了很大的困扰。即使开发者们可以在用户态通过线程池来模拟异步I/O的实现，
但这终归不是一个根本的解决办法。\par

Linux社区开发者们最初的想法是尝试改进AIO接口，并且持续了一段不短的时间，原因是：

\begin{enumerate}
  \item 如果有办法改善和优化现有的接口，会是相对于提供一个新接口的更优解。开发新接口不仅仅需要
    接口开发者投入精力，还需要社区对其进行各方面的审核和最终批准，这无疑是一项艰巨且漫长的任务。
  \item 对于应用开发者而言，新接口意味着他们要重新对应用程序进行兼容性适配，而扩展已有接口则只需要
    他们进行微小的改动。
\end{enumerate}

但是最终Linux社区的内核开发者们还是选择了设计并实现一个新的接口，以此来填补Linux平台上异步I/O接口的欠缺。
原因是：

\begin{enumerate}
  \item AIO接口存在三个系统调用，对多个系统调用的修改需要添加新的系统调用来传递信息，最终导致
    代码复杂性增高和可维护性变低，而且这仅仅解决了AIO接口的其中一个较为突出的问题。
  \item 修改AIO接口会引入新的问题（bug），或者会使得现有问题变得更加严重，比如会使得现有API变得复杂，难以使用。
\end{enumerate}

于是后来新时代的异步I/O接口出现了：io\underline{~}uring，于Linux 5.1版本开始提供，统一了整个Linux平台上的异步I/O框架。\par

\subsubsection{io\underline{~}uring设计目标}
在Linux开发者们开始设计并代码实现io\underline{~}uring之前，他们设定了新接口的设计目标：

\begin{enumerate}
  \item 易于使用，难以滥用；
  \item 可扩展的，该接口不仅仅用于块存储，还可用于网络和非块存储；
  \item 功能丰富；
  \item 高性能。
\end{enumerate}

尽管上述目标之间存在互斥的现象，但开发者们以此为行动纲领开发了io\underline{~}uring接口。\par

\subsubsection{io\underline{~}uring架构}
io\underline{~}uring架构大致如下图：\par

\cfig{io-uring}{0.8}{io\underline{~}uring架构图}

\subsubsection{io\underline{~}uring数据结构}
\subsubsection{io\underline{~}uring用户接口}

\subsection{有栈协程与无栈协程}
\subsection{Rust语言中的协程}
\subsection{C++语言中的协程}
\subsection{本章小结}
\section{系统设计}
\subsection{功能需求}
\subsection{系统总体设计}
\subsection{功能模块设计}
\subsection{本章小结}
\section{系统实现}
\subsection{xxx模块实现}
\subsection{xxx模块实现}
\subsection{本章小结}
\section{性能测试与分析}
\subsection{测试环境}
\subsection{功能测试}
\subsection{性能测试}
\subsection{本章小结}
\section{总结与展望}

\subsection{一张表}

这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一
张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。
这是一张表。这是一张表。这是一张表。

\begin{generaltab}{这是一张表}{tbl:hmm}
  \begin{tabular}{c|ccc}
    \toprule
    我是字 & 第二列 & 第三列 & 第四列 \\
    \midrule
    第一行 & $1$ & $1$ & $4$ \\
    第二行 & $5$ & $1$ & $4$ \\
    \bottomrule
  \end{tabular}
\end{generaltab}

\rtbl{hmm}是有味道的。

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\subsection{一堆表}

这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一
堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。
这是一堆图。这是一堆图。这是一堆图。

\cfig{bpg-1}{0.8}{一张大图}

\xfig{bpg-l}{两张小图}{
  \sfig{bpg-la}{0.3}{小图}
  \sfig{bpg-lb}{0.3}{小图}
}

\rfig{bpg-1}很好看，\rfig{bpg-la}和\rfig{bpg-lb}因为缩得太小了不那么好看。

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\begin{thankpage}

致谢

\end{thankpage}

\nocite{*}

\bibliography{thesis}
  % \bibitem{ref1}Conway, Melvin E. Design of a Separable Transition-diagram Compiler. Communications of the ACM (ACM). July 1963, 6 (7): 396–408. ISSN 0001-0782. doi:10.1145/366663.366704 –via ACM Digital Library.

\end{document}
