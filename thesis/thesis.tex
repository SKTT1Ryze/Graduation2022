\documentclass[supercite]{HustGraduPaper}

\title{高性能异步编程框架的设计与实现}
\author{车春池}
\school{计算机科学与技术}
\classnum{校际交流1801}
\stunum{U201816030}
\instructor{邵志远}
\date{2022年0月0日}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{xltxtra}
\usepackage{bm}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}

\pgfplotsset{compat=1.16}

\newcommand{\cfig}[3]{
  \begin{figure}[htb]
    \centering
    \includegraphics[width=#2\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{figure}
}
\newcommand{\sfig}[3]{
  \begin{subfigure}[b]{#2\textwidth}
    \includegraphics[width=\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{subfigure}
}
\newcommand{\xfig}[3]{
  \begin{figure}[htb]
    \centering
    #3
    \caption{#2}
    \label{fig:#1}
  \end{figure}
}

\newcommand{\rfig}[1]{\autoref{fig:#1}}
\newcommand{\ralg}[1]{\autoref{alg:#1}}
\newcommand{\rthm}[1]{\autoref{thm:#1}}
\newcommand{\rlem}[1]{\autoref{lem:#1}}
\newcommand{\reqn}[1]{\autoref{eqn:#1}}
\newcommand{\rtbl}[1]{\autoref{tbl:#1}}

\algnewcommand\Null{\textsc{null }}
\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\Input{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Output{\item[\algorithmicoutput]}
\algnewcommand\algorithmicbreak{\textbf{break}}
\algnewcommand\Break{\algorithmicbreak}
\algnewcommand\algorithmiccontinue{\textbf{continue}}
\algnewcommand\Continue{\algorithmiccontinue}
\algnewcommand{\LeftCom}[1]{\State $\triangleright$ #1}

\newtheorem{thm}{定理}[section]
\newtheorem{lem}{引理}[section]

\colorlet{shadecolor}{black!15}

\theoremstyle{definition}
\newtheorem{alg}{算法}[section]

\def\thmautorefname~#1\null{定理~#1~\null}
\def\lemautorefname~#1\null{引理~#1~\null}
\def\algautorefname~#1\null{算法~#1~\null}

\begin{document}

\maketitle

\statement

\clearpage

\pagenumbering{Roman}

\begin{cnabstract}{异步I/O；协程；异步编程框架}

在大数据时代，随着互联网用户体量的高速增长，数据中心面对数量越来越庞大，频度越来越高
的数据访问，对更为高效的数据输入输出（下文简称I/O）技术方案的需求也日益增长。
在此背景下，传统服务端开发中使用的同步数据I/O模式由于线程阻塞问题逐渐在性能考验上力不从心，
因此工业界和学术界正在探索和研究更为高效的异步I/O方案，希望以此来提高系统的整体性能。\par

同时，在系统并发编程领域，传统的多线程编程模式也慢慢展现出了它的弊端。近年来存储设备的性能
不断提高，现今某些高速存储设备进行一次I/O操作的开销已经能和一次线程切换的开销不分伯仲，
这意味着每进行一次线程切换系统就浪费一次I/O的时间。
面对线程切换开销重的现状，现代许多编程语言均提出了协程的概念，旨在提供一个更轻量，高效的并发编程模式。\par

本毕业设计以异步IO和协程为基点，设计和实现一款高性能的异步编程框架。
基于Linux io\underline{~}uring为底层异步I/O接口和使用无栈协程作为并发编程模式，
该框架具备高性能，低资源占用和易于编程的特点。
同时，对此框架进行性能测试，实验结果验证了异步I/O模式和协程能实实在在地对系统性能产生积极的影响。

\end{cnabstract}

\begin{enabstract}{Asynchronous I/O, Coroutine, Programming framework}

In the era of big data, with the rapid growth of the number of Internet users, data centers
are faced with increasingly large and frequent data access, and the demand for more efficient
data input and output technical solutions is also increasing. In this context, the synchronous
data IO mode used in traditional server development is gradually unable to perform performance
tests due to thread blocking problems.Therefore, the industry and academia are exploring and
researching more efficient asynchronous I/O solutions, hoping to improve the overall performance
of the system.\par

At the same time, in the field of system concurrent programming, the traditional multi-threaded
programming mode has gradually shown its drawbacks.In recent years, the performance of storage
devices has been continuously improved. Today, the overhead of one I/O operaion on some high-speed
storage devices is comparable to the overhead of on thread switching. This means that every time
the system is switched between threads, an I/O time is wasted. Faced with the current situation
of heavy thread switching overhead, many modern programming languages have proposed the concept
of coroutines, aiming to provide a lighter and more efficient concurrent programming model.\par

Based on asynchronous I/O and coroutines, this graduation project designs and implements a
high-performance asynchronous programming framwork. Based on Linux io\underline{~}uring as
the underlying asynchronous I/O interface and the use of stackless coroutines as a concurrent
programming mode, the framework has the characteristics of high performance, low resource consumption
and easy programming. At the same time, the performance of this framework is tested, and the
result of the experiment verify that asynchronous I/O modes and coroutines can actually have a
positive impact on system performance.\par

\end{enabstract}

\tableofcontents[level=2]
\clearpage

\pagenumbering{arabic}

\section{绪论}

这份模板根据\url{https://github.com/skinaze/HUSTPaperTemp}\cite{ski17}修改，添
加了一些CS人常用的东西。

我是绪论。我是绪论。我是绪论。我是绪论。我是绪论。我是绪论。我是绪论。我是绪论
。我是绪论。我是绪论。我是绪论。我是绪论。我是绪论。我是绪论。我是绪论。我是绪
论。

\subsection{第一小节}

我是第一小节。我是第一小节。我是第一小节。我是第一小节。我是第一小节。我是第一
小节。我是第一小节。我是第一小节。我是第一小节。我是第一小节。我是第一小节。我
是第一小节。我是第一小节。我是第一小节。我是第一小节。我是第一小节。我是第一小
节。我是第一小节。

\subsection{第二小节}

我是第二小节。我是第二小节。我是第二小节。我是第二小节。我是第二小节。我是第二
小节。我是第二小节。我是第二小节。我是第二小节。我是第二小节。我是第二小节。我
是第二小节。我是第二小节。我是第二小节。我是第二小节。我是第二小节。我是第二小
节。我是第二小节。

\section{还可以写很多}

\subsection{一个算法}

这是一个算法。这是一个算法。这是一个算法。这是一个算法。这是一个算法。这是一个
算法。这是一个算法。这是一个算法。这是一个算法。这是一个算法。这是一个算法。这
是一个算法。这是一个算法。这是一个算法。这是一个算法。

\begin{shaded*}\begin{alg}{一个复杂算法}
  \label{alg:apb}
  \begin{algorithmic}
    \Input Two numbers $a$ and $b$
    \Output The sum of $a$ and $b$
    \Procedure{A-Plus-B}{$a, b$}
      \If $a = 0$
        \State \Return $b$
      \EndIf
      \State $res \gets 0$
      \While{$b \neq 0$}
        \State Increase $res$ by $1$
        \State $b \gets b - 1$
      \EndWhile
      \State \Return $res$
    \EndProcedure
  \end{algorithmic}
\end{alg}\end{shaded*}

\begin{thm} \label{thm:gsb-apprx}
  \ralg{apb}所示的算法是正确的。
\end{thm}
\begin{proof}[证明]
  显然，此处略去。
\end{proof}

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\subsection{一张表}

这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一
张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。
这是一张表。这是一张表。这是一张表。

\begin{generaltab}{这是一张表}{tbl:hmm}
  \begin{tabular}{c|ccc}
    \toprule
    我是字 & 第二列 & 第三列 & 第四列 \\
    \midrule
    第一行 & $1$ & $1$ & $4$ \\
    第二行 & $5$ & $1$ & $4$ \\
    \bottomrule
  \end{tabular}
\end{generaltab}

\rtbl{hmm}是有味道的。

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\subsection{一堆表}

这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一
堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。
这是一堆图。这是一堆图。这是一堆图。

\cfig{bpg-1}{0.8}{一张大图}

\xfig{bpg-l}{两张小图}{
  \sfig{bpg-la}{0.3}{小图}
  \sfig{bpg-lb}{0.3}{小图}
}

\rfig{bpg-1}很好看，\rfig{bpg-la}和\rfig{bpg-lb}因为缩得太小了不那么好看。

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\begin{thankpage}

感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。感谢大萝卜给
我这次机会。感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。
感谢大萝卜给我这次机会。

感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。感谢大萝卜给
我这次机会。感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。
感谢大萝卜给我这次机会。

\end{thankpage}

\nocite{*}

\bibliography{sample}

\end{document}
