\documentclass[supercite]{HustGraduPaper}

\title{高性能异步编程框架的设计与实现}
\author{车春池}
\school{计算机科学与技术}
\classnum{校际交流1801}
\stunum{U201816030}
\instructor{邵志远}
\date{2022年0月0日}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{xltxtra}
\usepackage{bm}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}

\pgfplotsset{compat=1.16}

\newcommand{\cfig}[3]{
  \begin{figure}[htb]
    \centering
    \includegraphics[width=#2\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{figure}
}
\newcommand{\sfig}[3]{
  \begin{subfigure}[b]{#2\textwidth}
    \includegraphics[width=\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{subfigure}
}
\newcommand{\xfig}[3]{
  \begin{figure}[htb]
    \centering
    #3
    \caption{#2}
    \label{fig:#1}
  \end{figure}
}

\newcommand{\rfig}[1]{\autoref{fig:#1}}
\newcommand{\ralg}[1]{\autoref{alg:#1}}
\newcommand{\rthm}[1]{\autoref{thm:#1}}
\newcommand{\rlem}[1]{\autoref{lem:#1}}
\newcommand{\reqn}[1]{\autoref{eqn:#1}}
\newcommand{\rtbl}[1]{\autoref{tbl:#1}}

\algnewcommand\Null{\textsc{null }}
\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\Input{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Output{\item[\algorithmicoutput]}
\algnewcommand\algorithmicbreak{\textbf{break}}
\algnewcommand\Break{\algorithmicbreak}
\algnewcommand\algorithmiccontinue{\textbf{continue}}
\algnewcommand\Continue{\algorithmiccontinue}
\algnewcommand{\LeftCom}[1]{\State $\triangleright$ #1}

\newtheorem{thm}{定理}[section]
\newtheorem{lem}{引理}[section]

\colorlet{shadecolor}{black!15}

\theoremstyle{definition}
\newtheorem{alg}{算法}[section]

\def\thmautorefname~#1\null{定理~#1~\null}
\def\lemautorefname~#1\null{引理~#1~\null}
\def\algautorefname~#1\null{算法~#1~\null}

\begin{document}

\maketitle

\statement

\clearpage

\pagenumbering{Roman}

\begin{cnabstract}{异步I/O；协程；异步编程框架}

在大数据时代，随着互联网用户体量的高速增长，数据中心面对数量越来越庞大，频度越来越高
的数据访问，对更为高效的数据输入输出（下文简称I/O）技术方案的需求也日益增长。
在此背景下，传统服务端开发中使用的同步数据I/O模式由于线程阻塞问题逐渐在性能考验上力不从心，
因此工业界和学术界正在探索和研究更为高效的异步I/O方案，希望以此来提高系统的整体性能。\par

同时，在系统并发编程领域，传统的多线程编程模式也慢慢展现出了它的弊端。近年来存储设备的性能
不断提高，现今某些高速存储设备进行一次I/O操作的开销已经能和一次线程切换的开销不分伯仲，
这意味着每进行一次线程切换系统就浪费一次I/O的时间。
面对线程切换开销重的现状，现代许多编程语言均提出了协程的概念，旨在提供一个更轻量，高效的并发编程模式。\par

本毕业设计以异步IO和协程为基点，设计和实现一款高性能的异步编程框架。
基于Linux io\underline{~}uring为底层异步I/O接口和使用无栈协程作为并发编程模式，
该框架具备高性能，低资源占用和易于编程的特点。
同时，对此框架进行性能测试，实验结果验证了异步I/O模式和协程能实实在在地对系统性能产生积极的影响。

\end{cnabstract}

\begin{enabstract}{Asynchronous I/O, Coroutine, Programming framework}

In the era of big data, with the rapid growth of the number of Internet users, data centers
are faced with increasingly large and frequent data access, and the demand for more efficient
data input and output technical solutions is also increasing. In this context, the synchronous
data IO mode used in traditional server development is gradually unable to perform performance
tests due to thread blocking problems.Therefore, the industry and academia are exploring and
researching more efficient asynchronous I/O solutions, hoping to improve the overall performance
of the system.\par

At the same time, in the field of system concurrent programming, the traditional multi-threaded
programming mode has gradually shown its drawbacks.In recent years, the performance of storage
devices has been continuously improved. Today, the overhead of one I/O operaion on some high-speed
storage devices is comparable to the overhead of on thread switching. This means that every time
the system is switched between threads, an I/O time is wasted. Faced with the current situation
of heavy thread switching overhead, many modern programming languages have proposed the concept
of coroutines, aiming to provide a lighter and more efficient concurrent programming model.\par

Based on asynchronous I/O and coroutines, this graduation project designs and implements a
high-performance asynchronous programming framwork. Based on Linux io\underline{~}uring as
the underlying asynchronous I/O interface and the use of stackless coroutines as a concurrent
programming mode, the framework has the characteristics of high performance, low resource consumption
and easy programming. At the same time, the performance of this framework is tested, and the
result of the experiment verify that asynchronous I/O modes and coroutines can actually have a
positive impact on system performance.\par

\end{enabstract}

\tableofcontents[level=2]
\clearpage

\pagenumbering{arabic}

\section{绪论}

本章我们首先介绍了当前并发系统编程领域面临的挑战和技术发展趋势，然后分析了异步I/O和协程
的产生及发展现状，接着介绍了国内外针对异步编程框架的相关研究工作，最后对本文的主要研究内容
及工作意义作了具体说明。

\subsection{课题背景}

\subsubsection{研究背景和趋势}
Linux 平台上的I/O模型经历了几个发展阶段：阻塞，非阻塞，多路复用，信号驱动，异步。其中前四种均属于
同步I/O模式。同步I/O的共性是对于调用过程的双方：用户程序和硬件设备，它们之间流动的数据需要经过
操作系统内核进行同步，完全准备好后，才能复制到用户空间，用户程序才能继续往下执行。而数据等待的过程
会阻塞用户线程，直到整个I/O调用链路完成。线程阻塞问题导致了同步I/O的低效，因此异步I/O作为一个高性能
解决方案被提出，它的特点是用户程序发起I/O请求后，不需要进行任何的等待，可以从容地转向处理其他任务，
然后在合适的时机检查数据传输是否完成，再对该数据进行相应处理。异步I/O模式解决了线程阻塞的问题，
提高了资源利用率。\par

异步I/O通常需要操作系统内核提供支持。Linux 平台存在原生的异步I/O接口：libaio，但其存在复杂难用，性能低
等问题，因此Linux在很长一段时间内处于缺少异步I/O接口的状况。这导致系统存储领域在很多时候会采用
绕过内核(kernel bypass)作为高性能解决方案。终于，在5.1版本，Linux新增了io\underline{~}uring特性，
提供了一个简单易用，高性能的异步I/O接口。并且在随之而来的性能评估结果中，io\underline{~}uring 展现出
了足够强大的性能潜力。因此，基于io\underline{~}uring的学术研究和工程变革势在必行。\par

\subsubsection{异步I/O和协程的结合}
尽管异步I/O在理论上拥有比传统同步I/O更好的性能优势，但同时其带来的编程上的复杂性也是不容忽视的一部分。
如何降低异步I/O带来的编程复杂度，是软件开发者必需考虑的问题之一。针对这个问题，工业界提出了一个
解决方案：通过\textbf{协程}与异步I/O结合进而降低编程难度。\par

协程（英文 coroutine）一词最早出自于上个世纪的程序员马尔文·康威，关于协程的论文\cite{paper1}最早在
1963年发表。协程可以被理解为是一个可以随时挂起和恢复运行的函数。它可以通过\textbf{yield}
来让出当前CPU，然后运行其他协程；它也可以通过\textbf{resume}来恢复执行。当一个协程被恢复的时候，
它会从上次yield调用的位置继续执行。协程和线程类似，属于一种并发编程模式。\par

当协程和异步I/O结合后，可以让协程A在发起I/O请求后挂起，然后调度运行其他协程。等待I/O操作完成后，
再恢复运行协程A，这样就可以充分利用CPU资源。协程的运作模式和异步I/O浑然天成。\par

\subsubsection{面临的问题和挑战}
\textbf{高性能高可用的异步编程框架}。前两小节介绍的io\underline{~}uring和协程均为较原始，较底层的概念，
两者对于不熟悉操作系统和编程语言底层的一般应用软件开发者而言，无论是在理解原理上还是在工程实践上
都存在较高难度。在现代的软件开发领域，分层设计已成共识，因此上层应用开发者需要一个易用的
\textbf{异步编程框架}。通过该框架，他们可以在不了解io\underline{~}uring和协程底层原理的情况下
充分利用到两者的高性能特点，从中收益。\par

这种异步编程框架，在不同的编程语言里面存在不同称呼，比如在C++语言里面它被称为\textbf{协程库}，
在Rust语言里面被称为\textbf{异步运行时}。但是不管在哪种编程语言里面，它的存在意义是一致的：
对底层操作系统的异步I/O接口和编程语言层面的协程进行统一封装，向上层应用程序的构建提供简单易用的
异步编程接口。\par

遗憾的是，目前的系统编程领域的软件生态对于上述的异步编程框架暂时留有较大一片空白。尽管存在一些相关
的开源项目，但各自在实际应用中都暴露了或多或少的不足。因此我们分别基于Rust语言和C++语言设计并实现了
一个异步编程框架，对底层io\underline{~}uring和协程进行了封装，向上层应用开发提供了简单易用的编程接口，
希望可以借此解决传统并发编程和系统编程中的一些痛点。\par

\subsection{国内外研究现状}

\subsubsection{Tokio：Rust异步运行时}
在Rust语言开发领域内，上述的异步编程框架在这里被称为\textbf{异步运行时}（Async Runtime）。
Tokio\cite{repo1}是目前Rust社区里最成熟，也是为数不多广泛应用于工业界研发的Rust异步运行时。
Tokio 现已推出1.0版本，它提供了基于多线程池的协程调度器和基于epoll的异步网络编程接口。
同时，Tokio具有轻量，安全可靠的特点，它可以减少应用程序的崩溃和增加线上系统的稳定性。
但是，相比与在网络编程方面的优越性，Tokio在存储领域的表现则相形见绌，因为它在文件I/O上
使用的是同步I/O模式，而在上文已经提到过同步I/O的低效。\par

\subsubsection{Libco：C++协程库}
在C++语言开发领域内，上述的异步编程框架在这里被称为\textbf{协程库}。
在C++20之前，C++语言本身不支持协程，开发者们通常通过第三方协程库来获得协程的底层支持。
其中，微信团队开源的\textbf{libco}项目就是知名度较高的一个。libco是微信后台大规模使用的
C/C++协程库，自从2013年开始到如今仍稳定运行在微信后台的大规模服务器集群上。
微信作为支撑上亿用户的国民级软件，它所使用的协程库libco无疑在性能，稳定性上拥有非常优秀
的表现，但它仍然存在一定的缺点。一是libco对使用者的要求较高，一般开发者无法很好地驾驭；
二是C++20后在编程语言层面提供了协程支持，而C++20官方的协程标准和libco不兼容，
因此libco的使用价值会逐渐变小。\par

\subsubsection{Goroutine: Go语言原生协程}
说到协程，就不得不提一下Go语言从诞生之际就根植于其基因之中的\textbf{Goroutine}：Go语言原生协程。
Goroutine是Go语言中最为基本的执行单元，它本质上是Go语言原生的一种协程实现。
Go语言中的协程，也就是Goroutine，具有着易于编程的特点，只需要一行代码则可以生成一个协程，
并且开发者不需要关心其中的底层细节。可以说Go语言逐渐成为国内大厂后端开发的首选语言，
Goroutine功不可没。然而，Goroutine由于语言本身的垃圾回收机制，在性能上相比Rust/C++等
零成本开销语言稍逊一筹。同时，Go语言向开发者隐藏了底层协程调度等细节，也就意味着它剥夺了开发者
根据业务场景进行针对性优化的能力，而Rust/C++则能做到这一点。\par

\subsection{课题研究的意义，内容和目标}

\subsubsection{课题研究的意义}
本课题将围绕异步I/O和协程进行，目标是基于身为异步I/O接口之一的io\underline{~}uring和协程
设计并实现一款高性能的异步编程框架，
有助于解决传统并发编程中同步I/O阻塞线程和线程切换开销大的问题，存在能验证异步I/O和协程可以带来
性能提升的理论意义和向应用软件开发者提供简单易用，高性能的异步编程接口的实用意义。\par

\subsubsection{课题研究的内容}
\begin{enumerate}
  \item Linux io\underline{~}uring的底层原理和调用规范；
  \item Rust/C++协程的底层原理和编程范式；
  \item 构思设计如何结合io\underline{~}uring和协程实现异步编程框架；
  \item 将(3)中的设计落实到工程实践上，完成代码实现；
  \item 基于(4)中实现的异步编程框架进行性能测试，验证异步I/O和协程带来的性能优势。
\end{enumerate}

\subsubsection{课题研究的目标}
探索一种结合io\underline{~}uring和协程的编程模式，在将其代码实现为异步编程框架的同时，验证两者在
系统编程领域能否带来，能带来多少性能提升。\par

\subsection{论文结构}
xxx

\section{背景技术概述}

\subsection{算法}

这是一个算法。这是一个算法。这是一个算法。这是一个算法。这是一个算法。这是一个
算法。这是一个算法。这是一个算法。这是一个算法。这是一个算法。这是一个算法。这
是一个算法。这是一个算法。这是一个算法。这是一个算法。

\begin{shaded*}\begin{alg}{一个复杂算法}
  \label{alg:apb}
  \begin{algorithmic}
    \Input Two numbers $a$ and $b$
    \Output The sum of $a$ and $b$
    \Procedure{A-Plus-B}{$a, b$}
      \If $a = 0$
        \State \Return $b$
      \EndIf
      \State $res \gets 0$
      \While{$b \neq 0$}
        \State Increase $res$ by $1$
        \State $b \gets b - 1$
      \EndWhile
      \State \Return $res$
    \EndProcedure
  \end{algorithmic}
\end{alg}\end{shaded*}

\begin{thm} \label{thm:gsb-apprx}
  \ralg{apb}所示的算法是正确的。
\end{thm}
\begin{proof}[证明]
  显然，此处略去。
\end{proof}

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\subsection{一张表}

这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一
张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。这是一张表。
这是一张表。这是一张表。这是一张表。

\begin{generaltab}{这是一张表}{tbl:hmm}
  \begin{tabular}{c|ccc}
    \toprule
    我是字 & 第二列 & 第三列 & 第四列 \\
    \midrule
    第一行 & $1$ & $1$ & $4$ \\
    第二行 & $5$ & $1$ & $4$ \\
    \bottomrule
  \end{tabular}
\end{generaltab}

\rtbl{hmm}是有味道的。

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\subsection{一堆表}

这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一
堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。这是一堆表。
这是一堆图。这是一堆图。这是一堆图。

\cfig{bpg-1}{0.8}{一张大图}

\xfig{bpg-l}{两张小图}{
  \sfig{bpg-la}{0.3}{小图}
  \sfig{bpg-lb}{0.3}{小图}
}

\rfig{bpg-1}很好看，\rfig{bpg-la}和\rfig{bpg-lb}因为缩得太小了不那么好看。

我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字
。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是
字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。我是字。

\begin{thankpage}

感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。感谢大萝卜给
我这次机会。感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。
感谢大萝卜给我这次机会。

感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。感谢大萝卜给
我这次机会。感谢CCF给我这次机会。感谢CCTV给我这次机会。感谢HUST给我这次机会。
感谢大萝卜给我这次机会。

\end{thankpage}

\nocite{*}

\bibliography{thesis}
  % \bibitem{ref1}Conway, Melvin E. Design of a Separable Transition-diagram Compiler. Communications of the ACM (ACM). July 1963, 6 (7): 396–408. ISSN 0001-0782. doi:10.1145/366663.366704 –via ACM Digital Library.

\end{document}
